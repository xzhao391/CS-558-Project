Index: assignment1_part1_3d.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import division\r\nimport pybullet as p\r\nimport pybullet_data\r\nimport numpy as np\r\nimport time\r\nimport argparse\r\nimport math\r\nimport os\r\nimport sys\r\nimport random\r\nfrom scipy.spatial import KDTree\r\n\r\nUR5_JOINT_INDICES = [0, 1, 2]\r\n# parameter\r\nN_SAMPLE = 500  # number of sample_points\r\nN_KNN = 10  # number of edge from one sampled point\r\nMAX_EDGE_LEN = 30.0  # [m] Maximum edge length\r\n\r\ndef set_joint_positions(body, joints, values):\r\n    assert len(joints) == len(values)\r\n    for joint, value in zip(joints, values):\r\n        p.resetJointState(body, joint, value)\r\n\r\n\r\ndef draw_sphere_marker(position, radius, color):\r\n   vs_id = p.createVisualShape(p.GEOM_SPHERE, radius=radius, rgbaColor=color)\r\n   marker_id = p.createMultiBody(basePosition=position, baseCollisionShapeIndex=-1, baseVisualShapeIndex=vs_id)\r\n   return marker_id\r\n\r\n\r\ndef remove_marker(marker_id):\r\n   p.removeBody(marker_id)\r\n\r\n\r\ndef get_args():\r\n    parser = argparse.ArgumentParser()\r\n    parser.add_argument('--birrt', action='store_true', default=False)\r\n    parser.add_argument('--smoothing', action='store_true', default=False)\r\n    args = parser.parse_args()\r\n    return args\r\n\r\n#your implementation starts here\r\n#refer to the handout about what the these functions do and their return type\r\n###############################################################################\r\nclass Node:\r\n    def __init__(self, conf, cost, parent_index):\r\n        self.conf = conf\r\n        self.cost = cost\r\n        self.parent_index = parent_index\r\n\r\ndef steer_to(rand_conf, nearest_conf):\r\n    rand_conf = np.array(rand_conf)\r\n    nearest_conf = np.array(nearest_conf)\r\n    diff = rand_conf - nearest_conf\r\n    L = np.linalg.norm(diff)\r\n    n = math.floor(L/.05)\r\n    if n > 0:\r\n        dir = .05*diff/L\r\n    colide = collision_fn(rand_conf)\r\n    i = 0\r\n    while i < n:\r\n        if colide == True: break\r\n        i+=1\r\n        new_node = i*dir+nearest_conf\r\n        colide = collision_fn(new_node)\r\n    return colide\r\n\r\ndef prm_planning(start_conf, goal_conf):\r\n    \"\"\"\r\n    Run probabilistic road map planning\r\n\r\n    :param start_x: start x position\r\n    :param start_y: start y position\r\n    :param goal_x: goal x position\r\n    :param goal_y: goal y position\r\n    :param obstacle_x_list: obstacle x positions\r\n    :param obstacle_y_list: obstacle y positions\r\n    :param robot_radius: robot radius\r\n    :param rng: (Optional) Random generator\r\n    :return:\r\n    \"\"\"\r\n    sample_x, sample_y, sample_z = sample_points(start_conf, goal_conf)\r\n\r\n    road_map = generate_road_map(sample_x, sample_y, sample_z)\r\n\r\n    rx, ry, rz = dijkstra_planning(start_conf, goal_conf, road_map, sample_x, sample_y, sample_z)\r\n\r\n    path_conf = []\r\n    for i in reversed(range(len(rx))):\r\n        path_conf.append([rx[i], ry[i], rz[i]])\r\n    return path_conf\r\n\r\ndef dijkstra_planning(start_conf, goal_conf, road_map, sample_x, sample_y, sample_z):\r\n    open_set, closed_set = dict(), dict()\r\n    start_node = Node(start_conf, 0, -1)\r\n    goal_node = Node(goal_conf, 0, -1)\r\n    open_set[len(road_map) - 2] = start_node\r\n    path_found = True\r\n    while True:\r\n        if not open_set:\r\n            print(\"Cannot find path\")\r\n            path_found = False\r\n            break\r\n\r\n        c_id = min(open_set, key=lambda o: open_set[o].cost)\r\n        current = open_set[c_id]\r\n\r\n        if c_id == (len(road_map) - 1):\r\n            print(\"goal is found!\")\r\n            goal_node.parent_index = current.parent_index\r\n            goal_node.cost = current.cost\r\n            break\r\n\r\n        del open_set[c_id]\r\n        # Add it to the closed set\r\n        closed_set[c_id] = current\r\n\r\n        for i in range(len(road_map[c_id])):\r\n            n_id = road_map[c_id][i]\r\n            dx = sample_x[n_id] - current.conf[0]\r\n            dy = sample_y[n_id] - current.conf[1]\r\n            dz = sample_z[n_id] - current.conf[2]\r\n            d = math.hypot(dx, dy, dz)\r\n            node = Node([sample_x[n_id], sample_y[n_id], sample_z[n_id]]\r\n                        , current.cost + d, c_id)\r\n            if n_id in closed_set:\r\n                continue\r\n            if n_id in open_set:\r\n                if open_set[n_id].cost > node.cost:\r\n                    open_set[n_id].cost = node.cost\r\n                    open_set[n_id].parent_index = c_id\r\n            else:\r\n                open_set[n_id] = node\r\n\r\n    if path_found is False:\r\n        return [], [], []\r\n    rx, ry, rz = [goal_node.conf[0]], [goal_node.conf[1]], [goal_node.conf[2]]\r\n    parent_index = goal_node.parent_index\r\n    while parent_index != -1:\r\n        n = closed_set[parent_index]\r\n        rx.append(n.conf[0])\r\n        ry.append(n.conf[1])\r\n        rz.append(n.conf[2])\r\n        parent_index = n.parent_index\r\n    return rx, ry, rz\r\n\r\n\r\n\r\ndef sample_points(start_conf, goal_conf):\r\n    sample_x, sample_y, sample_z = [], [], []\r\n    while len(sample_x) <= N_SAMPLE:\r\n        # tx = np.random.uniform(-2*np.pi, 2*np.pi)\r\n        # ty = np.random.uniform(-2*np.pi, 2*np.pi)\r\n        # tz = np.random.uniform(-np.pi, np.pi)\r\n        tx = np.random.uniform(goal_conf[0]-1.6, goal_conf[0]+.1)\r\n        ty = np.random.uniform(goal_conf[1]-.1, goal_conf[1]+.5)\r\n        tz = np.random.uniform(goal_conf[2]-.1, goal_conf[2]+.5)\r\n        rand_conf = [tx, tz, ty]\r\n        colide = collision_fn(rand_conf)\r\n        if not colide:\r\n            sample_x.append(tx)\r\n            sample_y.append(ty)\r\n            sample_z.append(tz)\r\n\r\n    sample_x.append(start_conf[0])\r\n    sample_y.append(start_conf[1])\r\n    sample_z.append(start_conf[2])\r\n    sample_x.append(goal_conf[0])\r\n    sample_y.append(goal_conf[1])\r\n    sample_z.append(goal_conf[2])\r\n    return sample_x, sample_y, sample_z\r\n\r\ndef generate_road_map(sample_x, sample_y, sample_z):\r\n    road_map = []\r\n    n_sample = len(sample_x)\r\n    sample_kd_tree = KDTree(np.vstack((sample_x, sample_y, sample_z)).T)\r\n\r\n    for (i, ix, iy, iz) in zip(range(n_sample), sample_x, sample_y, sample_z):\r\n        dists, indexes = sample_kd_tree.query([ix, iy, iz], k=n_sample)\r\n        edge_id = []\r\n        for ii in range(1, len(indexes)):\r\n            nx = sample_x[indexes[ii]]\r\n            ny = sample_y[indexes[ii]]\r\n            nz = sample_z[indexes[ii]]\r\n\r\n            colide = steer_to([ix, iy, iz], [nx, ny, nz])\r\n            if not colide:\r\n                edge_id.append(indexes[ii])\r\n\r\n            if len(edge_id) >= N_KNN:\r\n                break\r\n        road_map.append(edge_id)\r\n    return road_map\r\n\r\n###############################################################################\r\n#your implementation ends here\r\n\r\nif __name__ == \"__main__\":\r\n    args = get_args()\r\n\r\n    # set up simulator\r\n    physicsClient = p.connect(p.GUI)\r\n    p.setAdditionalSearchPath(pybullet_data.getDataPath())\r\n    p.setPhysicsEngineParameter(enableFileCaching=0)\r\n    p.setGravity(0, 0, -9.8)\r\n    p.configureDebugVisualizer(p.COV_ENABLE_GUI, False)\r\n    p.configureDebugVisualizer(p.COV_ENABLE_SHADOWS, True)\r\n    p.resetDebugVisualizerCamera(cameraDistance=1.400, cameraYaw=58.000, cameraPitch=-42.200, cameraTargetPosition=(0.0, 0.0, 0.0))\r\n\r\n    # load objects\r\n    plane = p.loadURDF(\"plane.urdf\")\r\n    ur5 = p.loadURDF('assets/ur5/ur5.urdf', basePosition=[0, 0, 0.02], useFixedBase=True)\r\n    obstacle1 = p.loadURDF('assets/block.urdf',\r\n                           basePosition=[1/4, 0, 1/2],\r\n                           useFixedBase=True)\r\n    obstacle2 = p.loadURDF('assets/block.urdf',\r\n                           basePosition=[2/4, 0, 2/3],\r\n                           useFixedBase=True)\r\n    obstacles = [plane, obstacle1, obstacle2]\r\n\r\n    # start and goal\r\n    start_conf = (-0.813358794499552, -0.37120422397572495, -0.754454729356351)\r\n    start_position = (0.3998897969722748, -0.3993956744670868, 0.6173484325408936)\r\n    goal_conf = (0.7527214782907734, -0.6521867735052328, -0.4949270744967443)\r\n    goal_position = (0.35317009687423706, 0.35294029116630554, 0.7246701717376709)\r\n    goal_marker = draw_sphere_marker(position=goal_position, radius=0.02, color=[1, 0, 0, 1])\r\n    set_joint_positions(ur5, UR5_JOINT_INDICES, start_conf)\r\n\r\n    # get the collision checking function\r\n    from collision_utils import get_collision_fn\r\n    collision_fn = get_collision_fn(ur5, UR5_JOINT_INDICES, obstacles=obstacles,\r\n                                       attachments=[], self_collisions=True,\r\n                                       disabled_collisions=set())\r\n\r\n    path_conf = prm_planning(start_conf, goal_conf)\r\n\r\n\r\n    if path_conf is None:\r\n        # pause here\r\n        input(\"no collision-free path is found within the time budget, finish?\")\r\n    else:\r\n        # execute the path\r\n        while True:\r\n            for q in path_conf:\r\n                set_joint_positions(ur5, UR5_JOINT_INDICES, q)\r\n                time.sleep(0.3)\r\n            time.sleep(1)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/assignment1_part1_3d.py b/assignment1_part1_3d.py
--- a/assignment1_part1_3d.py	
+++ b/assignment1_part1_3d.py	
@@ -149,12 +149,12 @@
 def sample_points(start_conf, goal_conf):
     sample_x, sample_y, sample_z = [], [], []
     while len(sample_x) <= N_SAMPLE:
-        # tx = np.random.uniform(-2*np.pi, 2*np.pi)
-        # ty = np.random.uniform(-2*np.pi, 2*np.pi)
-        # tz = np.random.uniform(-np.pi, np.pi)
-        tx = np.random.uniform(goal_conf[0]-1.6, goal_conf[0]+.1)
-        ty = np.random.uniform(goal_conf[1]-.1, goal_conf[1]+.5)
-        tz = np.random.uniform(goal_conf[2]-.1, goal_conf[2]+.5)
+        tx = np.random.uniform(-2*np.pi, 2*np.pi)
+        ty = np.random.uniform(-2*np.pi, 2*np.pi)
+        tz = np.random.uniform(-np.pi, np.pi)
+        # tx = np.random.uniform(goal_conf[0]-1.6, goal_conf[0]+.1)
+        # ty = np.random.uniform(goal_conf[1]-.1, goal_conf[1]+.5)
+        # tz = np.random.uniform(goal_conf[2]-.1, goal_conf[2]+.5)
         rand_conf = [tx, tz, ty]
         colide = collision_fn(rand_conf)
         if not colide:
